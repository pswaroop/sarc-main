{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/Documents/Staffarc Projects/staffArcv0/staffarc/app/api/chat/route.ts"],"sourcesContent":["// import { google } from '@ai-sdk/google';\n// import { streamText } from 'ai';\n// import { NextRequest, NextResponse } from 'next/server';\n\n// // Use Edge runtime for faster, serverless streaming\n// export const runtime = 'edge';\n\n// export async function POST(req: NextRequest) {\n//   try {\n//     // Check if API key exists\n//     if (!process.env.GOOGLE_GENERATIVE_AI_API_KEY) {\n//       console.error('Missing GOOGLE_GENERATIVE_AI_API_KEY');\n//       return NextResponse.json(\n//         { error: 'AI Configuration Error. Please contact support.' },\n//         { status: 500 }\n//       );\n//     }\n\n//     const { messages } = await req.json();\n\n//     // Validate incoming messages\n//     if (!Array.isArray(messages)) {\n//       return NextResponse.json(\n//         { error: 'Invalid messages format' },\n//         { status: 400 }\n//       );\n//     }\n\n//     // Stream the response using Gemini\n//     const result = await streamText({\n//       model: google('gemini-2.0-flash'), // Google's fast, efficient model\n//       maxOutputTokens: 1000,             // âœ… FIX: Use maxOutputTokens instead of maxTokens\n//       temperature: 0.7,\n//       // Map messages to ensure the correct role formatting\n//       messages: messages.map((msg: any) => ({\n//         role: msg.role === 'bot' ? 'assistant' : msg.role,\n//         content: msg.content,\n//       })),\n//     });\n\n//     // Return the streaming text response to the client\n//     return result.toTextStreamResponse();\n//   } catch (error) {\n//     console.error('Chat API Error:', error);\n    \n//     // Return a generic error so the frontend fallback logic triggers\n//     return NextResponse.json(\n//       { error: 'AI service temporarily unavailable. Please try again.' },\n//       { status: 500 }\n//     );\n//   }\n// }\n// app/api/chat/route.ts\n// app/api/chat/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport const runtime = \"edge\";\n\nconst MODEL = \"@cf/meta/llama-3.2-3b-instruct\";\n\nfunction extractSseEvents(buffer: string): { events: string[]; rest: string } {\n  const events: string[] = [];\n  let idx = buffer.indexOf(\"\\n\\n\");\n  while (idx !== -1) {\n    events.push(buffer.slice(0, idx));\n    buffer = buffer.slice(idx + 2);\n    idx = buffer.indexOf(\"\\n\\n\");\n  }\n  return { events, rest: buffer };\n}\n\nfunction getDataFromSseEvent(eventBlock: string): string | null {\n  const lines = eventBlock.split(\"\\n\");\n  const dataLines = lines\n    .filter((l) => l.startsWith(\"data:\"))\n    .map((l) => l.slice(5).trim());\n  if (dataLines.length === 0) return null;\n  return dataLines.join(\"\\n\");\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;\n    const apiToken = process.env.CLOUDFLARE_API_TOKEN;\n\n    if (!accountId || !apiToken) {\n      return NextResponse.json(\n        { error: \"Missing CLOUDFLARE_ACCOUNT_ID / CLOUDFLARE_API_TOKEN\" },\n        { status: 500 }\n      );\n    }\n\n    const body = await req.json();\n    const messages = body?.messages;\n\n    if (!Array.isArray(messages)) {\n      return NextResponse.json({ error: \"Invalid messages format\" }, { status: 400 });\n    }\n\n    const cfMessages = messages.map((msg: any) => ({\n      role: msg.role === \"bot\" ? \"assistant\" : msg.role, // keep system/user/assistant\n      content: msg.content,\n    }));\n\n    const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/ai/run/${MODEL}`;\n\n    const cfRes = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${apiToken}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        messages: cfMessages,\n        max_tokens: 1000,\n        temperature: 0.7,\n        stream: true,\n      }),\n    });\n\n    if (!cfRes.ok) {\n      const errText = await cfRes.text();\n      return NextResponse.json({ error: \"Workers AI error\", details: errText }, { status: 500 });\n    }\n\n    if (!cfRes.body) {\n      return NextResponse.json({ error: \"Missing Workers AI response body\" }, { status: 500 });\n    }\n\n    // Convert Cloudflare SSE -> plain text stream for your React client\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n\n    const stream = new ReadableStream<Uint8Array>({\n      async start(controller) {\n        const reader = cfRes.body!.getReader();\n        let sseBuffer = \"\";\n\n        try {\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n\n            sseBuffer += decoder.decode(value, { stream: true });\n\n            const { events, rest } = extractSseEvents(sseBuffer);\n            sseBuffer = rest;\n\n            for (const ev of events) {\n              const data = getDataFromSseEvent(ev);\n              if (!data) continue;\n\n              if (data === \"[DONE]\") {\n                controller.close();\n                return;\n              }\n\n              // Expected: data: {\"response\":\"...\"}\n              try {\n                const parsed = JSON.parse(data);\n                const token = typeof parsed?.response === \"string\" ? parsed.response : \"\";\n                if (token) controller.enqueue(encoder.encode(token));\n              } catch {\n                // ignore non-JSON events\n              }\n            }\n          }\n\n          controller.close();\n        } catch (e) {\n          controller.error(e);\n        } finally {\n          try {\n            reader.releaseLock();\n          } catch {}\n        }\n      },\n    });\n\n    return new Response(stream, {\n      headers: {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        \"Cache-Control\": \"no-cache\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Chat API Error:\", error);\n    return NextResponse.json(\n      { error: \"AI service temporarily unavailable. Please try again.\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}